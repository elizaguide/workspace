<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eliza</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #0f0f1a;
      --bg-chat: #1a1a2e;
      --bg-input: #252542;
      --bg-user: #3730a3;
      --bg-assistant: #1e1e3f;
      --accent: #a78bfa;
      --accent-hover: #8b5cf6;
      --text: #f0f0f5;
      --text-dim: #888;
      --border: #333;
      --success: #4ade80;
      --error: #f87171;
    }

    html, body {
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      max-width: 900px;
      margin: 0 auto;
    }

    /* Header */
    header {
      display: flex;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-chat);
    }
    header .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), #6366f1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      margin-right: 12px;
    }
    header .info h1 { font-size: 18px; font-weight: 600; }
    header .info .status { font-size: 12px; color: var(--text-dim); }
    header .info .status.connected { color: var(--success); }
    header .info .status.error { color: var(--error); }

    /* Messages */
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: var(--bg);
    }

    .message {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: 16px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .message.user {
      align-self: flex-end;
      background: var(--bg-user);
      border-bottom-right-radius: 4px;
    }
    .message.assistant {
      align-self: flex-start;
      background: var(--bg-assistant);
      border-bottom-left-radius: 4px;
    }
    .message .meta {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 6px;
    }
    .message img {
      max-width: 100%;
      border-radius: 8px;
      margin-top: 8px;
    }
    .message.streaming::after {
      content: '▋';
      animation: blink 1s infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }

    .typing-indicator {
      align-self: flex-start;
      padding: 12px 16px;
      background: var(--bg-assistant);
      border-radius: 16px;
      display: none;
    }
    .typing-indicator.visible { display: block; }
    .typing-indicator span {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: var(--text-dim);
      border-radius: 50%;
      margin-right: 4px;
      animation: bounce 1.4s infinite ease-in-out;
    }
    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes bounce {
      0%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-6px); }
    }

    /* Input Area */
    #input-area {
      border-top: 1px solid var(--border);
      background: var(--bg-chat);
      padding: 16px 20px;
    }

    #drop-zone {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      display: none;
      text-align: center;
      color: var(--text-dim);
      transition: all 0.2s;
    }
    #drop-zone.visible { display: block; }
    #drop-zone.dragover {
      border-color: var(--accent);
      background: rgba(167, 139, 250, 0.1);
      color: var(--accent);
    }

    #attachments {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .attachment-preview {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-input);
    }
    .attachment-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .attachment-preview .remove {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: rgba(0,0,0,0.7);
      border: none;
      border-radius: 50%;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
    }

    #input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    #message-input {
      flex: 1;
      min-height: 100px;
      max-height: 300px;
      padding: 14px 16px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--bg-input);
      color: var(--text);
      font-size: 16px;
      font-family: inherit;
      resize: none;
      line-height: 1.5;
    }
    #message-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    #message-input::placeholder { color: var(--text-dim); }

    .btn-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    button {
      padding: 12px 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    #send-btn {
      background: var(--accent);
      color: #fff;
      min-width: 80px;
    }
    #send-btn:hover { background: var(--accent-hover); }
    #send-btn:disabled { background: #444; cursor: not-allowed; }

    #attach-btn {
      background: var(--bg-input);
      color: var(--text);
      border: 1px solid var(--border);
    }
    #attach-btn:hover { border-color: var(--accent); }

    .icon {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    input[type="file"] { display: none; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="avatar">✨</div>
      <div class="info">
        <h1>Eliza</h1>
        <div id="status" class="status">Connecting...</div>
      </div>
    </header>

    <div id="messages">
      <div class="typing-indicator" id="typing">
        <span></span><span></span><span></span>
      </div>
    </div>

    <div id="input-area">
      <div id="drop-zone">Drop images here</div>
      <div id="attachments"></div>
      <div id="input-wrapper">
        <textarea id="message-input" placeholder="Message Eliza... (drag & drop images, or paste with Cmd+V)" rows="3"></textarea>
        <div class="btn-group">
          <button id="attach-btn" title="Attach image">
            <svg class="icon" viewBox="0 0 24 24"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"/></svg>
          </button>
          <button id="send-btn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <input type="file" id="file-input" accept="image/*" multiple>

  <script>
    const GATEWAY_URL = 'ws://127.0.0.1:18789';
    const SESSION_KEY = 'agent:main:main';
    const PROTOCOL_VERSION = 3;

    let ws = null;
    let requestId = 0;
    let pendingAttachments = [];
    let isStreaming = false;
    let currentStreamEl = null;

    const statusEl = document.getElementById('status');
    const messagesEl = document.getElementById('messages');
    const typingEl = document.getElementById('typing');
    const dropZone = document.getElementById('drop-zone');
    const attachmentsEl = document.getElementById('attachments');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const attachBtn = document.getElementById('attach-btn');
    const fileInput = document.getElementById('file-input');

    // WebSocket connection
    function connect() {
      ws = new WebSocket(GATEWAY_URL);

      ws.onopen = () => {
        statusEl.textContent = 'Authenticating...';
        // Send proper connect frame with type: "req"
        const connectFrame = {
          type: 'req',
          method: 'connect',
          id: `connect-${++requestId}`,
          params: {
            minProtocol: PROTOCOL_VERSION,
            maxProtocol: PROTOCOL_VERSION,
            client: {
              id: 'webchat',
              displayName: 'Eliza UI',
              version: '1.0.0',
              platform: 'web',
              mode: 'webchat'
            },
            auth: {
              token: localStorage.getItem('eliza-token') || prompt('Enter gateway token:')
            }
          }
        };
        ws.send(JSON.stringify(connectFrame));
      };

      ws.onclose = () => {
        statusEl.textContent = 'Disconnected - reconnecting...';
        statusEl.className = 'status error';
        setTimeout(connect, 3000);
      };

      ws.onerror = () => {
        statusEl.textContent = 'Connection error';
        statusEl.className = 'status error';
      };

      ws.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          handleMessage(msg);
        } catch {}
      };
    }

    function handleMessage(msg) {
      // Handle hello-ok response (connection established)
      if (msg.type === 'res' && msg.payload?.type === 'hello-ok') {
        statusEl.textContent = 'Connected';
        statusEl.className = 'status connected';
        loadHistory();
        return;
      }

      // Handle connect error
      if (msg.type === 'res' && !msg.ok && msg.id?.startsWith('connect-')) {
        statusEl.textContent = `Auth failed: ${msg.error?.message || 'unknown'}`;
        statusEl.className = 'status error';
        return;
      }

      // Handle chat.history response
      if (msg.type === 'res' && msg.id?.startsWith('history-') && msg.payload?.messages) {
        renderHistory(msg.payload.messages);
        return;
      }

      // Handle streaming deltas (events don't have type:"res")
      if (msg.method === 'chat' && msg.params) {
        const p = msg.params;

        if (p.state === 'started') {
          typingEl.classList.add('visible');
          isStreaming = true;
        }

        if (p.state === 'delta' && p.text) {
          typingEl.classList.remove('visible');
          if (!currentStreamEl) {
            currentStreamEl = addMessage('assistant', '', true);
          }
          currentStreamEl.querySelector('.content').textContent += p.text;
          scrollToBottom();
        }

        if (p.state === 'final') {
          typingEl.classList.remove('visible');
          isStreaming = false;
          if (currentStreamEl) {
            currentStreamEl.classList.remove('streaming');
          }
          currentStreamEl = null;

          if (p.message?.content) {
            const text = p.message.content.map(c => c.text || '').join('');
            if (text && !document.querySelector('.message.assistant:last-of-type')) {
              addMessage('assistant', text);
            }
          }
        }

        if (p.state === 'error') {
          typingEl.classList.remove('visible');
          isStreaming = false;
          currentStreamEl = null;
          addMessage('assistant', `Error: ${p.errorMessage || 'Unknown error'}`);
        }
      }
    }

    function loadHistory() {
      const historyFrame = {
        type: 'req',
        method: 'chat.history',
        id: `history-${++requestId}`,
        params: { sessionKey: SESSION_KEY, limit: 50 }
      };
      ws.send(JSON.stringify(historyFrame));
    }

    function renderHistory(messages) {
      // Clear existing messages except typing indicator
      const toRemove = messagesEl.querySelectorAll('.message');
      toRemove.forEach(el => el.remove());

      messages.forEach(msg => {
        if (msg.role === 'user' || msg.role === 'assistant') {
          const text = msg.content?.map(c => c.text || '').join('') || '';
          if (text.trim()) {
            addMessage(msg.role, text);
          }
        }
      });
      scrollToBottom();
    }

    function addMessage(role, text, streaming = false) {
      const div = document.createElement('div');
      div.className = `message ${role}${streaming ? ' streaming' : ''}`;

      const content = document.createElement('div');
      content.className = 'content';
      content.textContent = text;
      div.appendChild(content);

      messagesEl.insertBefore(div, typingEl);
      scrollToBottom();
      return div;
    }

    function scrollToBottom() {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // File handling
    function handleFiles(files) {
      Array.from(files).forEach(file => {
        if (!file.type.startsWith('image/')) return;
        if (file.size > 5 * 1024 * 1024) {
          alert('Image too large (max 5MB)');
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target.result;
          const base64 = dataUrl.split(',')[1];

          const attachment = {
            content: base64,
            mimeType: file.type,
            fileName: file.name,
            preview: dataUrl
          };

          pendingAttachments.push(attachment);
          renderAttachments();
        };
        reader.readAsDataURL(file);
      });
    }

    function renderAttachments() {
      attachmentsEl.innerHTML = '';
      pendingAttachments.forEach((att, idx) => {
        const div = document.createElement('div');
        div.className = 'attachment-preview';
        div.innerHTML = `
          <img src="${att.preview}" alt="${att.fileName}">
          <button class="remove" data-idx="${idx}">&times;</button>
        `;
        attachmentsEl.appendChild(div);
      });
    }

    attachmentsEl.addEventListener('click', (e) => {
      if (e.target.classList.contains('remove')) {
        const idx = parseInt(e.target.dataset.idx);
        pendingAttachments.splice(idx, 1);
        renderAttachments();
      }
    });

    // Send message
    function send() {
      const text = messageInput.value.trim();
      if (!text && pendingAttachments.length === 0) return;
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      // Show user message
      let displayText = text;
      if (pendingAttachments.length > 0) {
        displayText += (text ? '\n' : '') + `[${pendingAttachments.length} image(s)]`;
      }
      addMessage('user', displayText);

      // Build payload
      const sendFrame = {
        type: 'req',
        method: 'chat.send',
        id: `send-${++requestId}`,
        params: {
          sessionKey: SESSION_KEY,
          message: text || 'Here is an image:',
          idempotencyKey: crypto.randomUUID()
        }
      };

      if (pendingAttachments.length > 0) {
        sendFrame.params.attachments = pendingAttachments.map(a => ({
          content: a.content,
          mimeType: a.mimeType,
          fileName: a.fileName
        }));
      }

      ws.send(JSON.stringify(sendFrame));

      // Reset
      messageInput.value = '';
      pendingAttachments = [];
      renderAttachments();
      messageInput.style.height = 'auto';
    }

    // Event listeners
    sendBtn.addEventListener('click', send);

    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

    // Auto-resize textarea
    messageInput.addEventListener('input', () => {
      messageInput.style.height = 'auto';
      messageInput.style.height = Math.min(messageInput.scrollHeight, 300) + 'px';
    });

    // Attach button
    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    // Drag and drop
    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dropZone.classList.add('visible');
    });

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      if (!dropZone.contains(e.relatedTarget)) {
        dropZone.classList.remove('dragover');
        dropZone.classList.remove('visible');
      }
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      dropZone.classList.remove('visible');
      handleFiles(e.dataTransfer.files);
    });

    document.addEventListener('dragleave', (e) => {
      if (e.target === document.documentElement) {
        dropZone.classList.remove('visible');
      }
    });

    // Paste images
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      const imageItems = Array.from(items).filter(item => item.type.startsWith('image/'));
      if (imageItems.length > 0) {
        e.preventDefault();
        imageItems.forEach(item => {
          const file = item.getAsFile();
          if (file) handleFiles([file]);
        });
      }
    });

    // Focus input on load
    messageInput.focus();

    // Start connection
    connect();
  </script>
</body>
</html>
